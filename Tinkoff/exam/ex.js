// Функция canWin принимает два массива a и b и возвращает true, если ковбой Джо может получить выигрышную последовательность с помощью применения операции один раз.
function canWin(a, b) {
    // Если последовательности a и b уже совпадают, то он не нуждается в применении операции. В этом случае он уже имеет выигрышную последовательность.
    if (a === b || a.sort().join("") === b.join("")) {
        return true;
    }
    // Найти самую длинную возрастающую подпоследовательность (ЛИС) в последовательности a. Это можно сделать, используя алгоритм динамического программирования, который найдет длину ЛИС.
    const lis = longestIncreasingSubsequence(a);
    // Если длина этой ЛИС больше или равна длине последовательности b, то он может просто выбрать элементы из этой ЛИС в соответствии с порядком в b.
    if (lis.length >= b.length) {
        return true;
    }
    // Если длина ЛИС меньше длины b, то ему придется выполнить дополнительные шаги.
    // Он должен найти первую карту в b, которая не присутствует в ЛИС. Пусть это будет карта с индексом i в b.
    const i = b.findIndex((x) => !lis.includes(x));
    // Затем он должен найти самую правую карту с таким же значением, как и карта в b[i] в ЛИС. Пусть это будет карта с индексом j в ЛИС.
    const j = lis.lastIndexOf(b[i]);
    // Затем он должен обменять подпоследовательность [i, j] в ЛИС на подпоследовательность из b[i:j+1]. Теперь у него есть выигрышная последовательность.
    const subsequence = b.slice(i, j + 1);
    subsequence.reverse();
    return [...a.slice(0, i), ...subsequence, ...a.slice(j + 1)].sort().join("") === b.join("");
}

// Функция longestIncreasingSubsequence принимает массив a и возвращает самую длинную возрастающую подпоследовательность (ЛИС) этого массива.
function longestIncreasingSubsequence(a) {
    const dp = Array(a.length).fill(1);
    for (let i = 1; i < a.length; i++) {
        for (let j = 0; j < i; j++) {
            if (a[i] > a[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return a.filter((_, i) => dp[i] === Math.max(...dp));
}
